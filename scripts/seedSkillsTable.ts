import { mkdirSync, writeFileSync } from "node:fs";
import path from "node:path";

import { SKILL_TREE_DEFINITIONS, SKILL_TREE_RELATIONSHIPS } from "../src/data/skillTree";

type SkillRow = {
  skill_id: string;
  skill_name: string;
  skill_parent_id: string | null;
  skill_child_id: string[];
  xp_impact: number;
};

const OUTPUT_DIRECTORY = path.resolve(__dirname, "../supabase/seed");
const OUTPUT_FILE = path.join(OUTPUT_DIRECTORY, "skills_seed.sql");

const ensureDirectory = (directory: string) => {
  mkdirSync(directory, { recursive: true });
};

const buildSkillRows = (): SkillRow[] => {
  const parentBySlug = new Map<string, string | null>();
  const childrenBySlug = new Map<string, Set<string>>();

  for (const definition of SKILL_TREE_DEFINITIONS) {
    parentBySlug.set(definition.slug, null);
    if (!childrenBySlug.has(definition.slug)) {
      childrenBySlug.set(definition.slug, new Set());
    }
  }

  for (const relationship of SKILL_TREE_RELATIONSHIPS) {
    const metadata = relationship.metadata as { type?: unknown } | undefined;
    const type = typeof metadata?.type === "string" ? metadata.type : undefined;

    if (type !== "tier_prerequisite") {
      continue;
    }

    const existingParent = parentBySlug.get(relationship.skill_slug);
    if (existingParent && existingParent !== relationship.required_skill_slug) {
      throw new Error(
        `Skill "${relationship.skill_slug}" already has parent "${existingParent}" but received "${relationship.required_skill_slug}"`
      );
    }

    parentBySlug.set(relationship.skill_slug, relationship.required_skill_slug);
    if (!childrenBySlug.has(relationship.required_skill_slug)) {
      childrenBySlug.set(relationship.required_skill_slug, new Set());
    }

    childrenBySlug.get(relationship.required_skill_slug)!.add(relationship.skill_slug);
  }

  const rows: SkillRow[] = [];

  for (const definition of SKILL_TREE_DEFINITIONS) {
    const slug = definition.slug;
    const skillName = definition.display_name ?? definition.slug;
    const xpImpact = definition.base_xp_gain ?? 0;
    const parentSlug = parentBySlug.get(slug) ?? null;
    const childSlugs = Array.from(childrenBySlug.get(slug) ?? new Set());
    childSlugs.sort();

    rows.push({
      skill_id: slug,
      skill_name: skillName,
      skill_parent_id: parentSlug,
      skill_child_id: childSlugs,
      xp_impact: xpImpact
    });
  }

  rows.sort((a, b) => a.skill_id.localeCompare(b.skill_id));

  return rows;
};

const escapeLiteral = (value: string): string => value.replace(/'/g, "''");

const formatArrayLiteral = (values: string[]): string => {
  if (values.length === 0) {
    return "ARRAY[]::text[]";
  }

  const escapedValues = values.map((value) => `'${escapeLiteral(value)}'`);
  return `ARRAY[${escapedValues.join(", ")}]::text[]`;
};

const buildInsertStatement = (row: SkillRow): string => {
  const columns = [
    "skill_id",
    "skill_name",
    "skill_child_id",
    "skill_parent_id",
    "learning_impact",
    "performance_impact",
    "xp_impact",
    "recording_impact",
    "writing_impact",
    "fame_impact",
    "sales_impact"
  ];

  const values = [
    `'${escapeLiteral(row.skill_id)}'`,
    `'${escapeLiteral(row.skill_name)}'`,
    formatArrayLiteral(row.skill_child_id),
    row.skill_parent_id ? `'${escapeLiteral(row.skill_parent_id)}'` : "NULL",
    "0",
    "0",
    row.xp_impact.toString(),
    "0",
    "0",
    "0",
    "0"
  ];

  return `INSERT INTO public.skills (${columns.join(", ")})\nVALUES (${values.join(", ")})\nON CONFLICT (skill_id) DO UPDATE\nSET\n  skill_name = EXCLUDED.skill_name,\n  skill_child_id = EXCLUDED.skill_child_id,\n  skill_parent_id = EXCLUDED.skill_parent_id,\n  learning_impact = EXCLUDED.learning_impact,\n  performance_impact = EXCLUDED.performance_impact,\n  xp_impact = EXCLUDED.xp_impact,\n  recording_impact = EXCLUDED.recording_impact,\n  writing_impact = EXCLUDED.writing_impact,\n  fame_impact = EXCLUDED.fame_impact,\n  sales_impact = EXCLUDED.sales_impact;`;
};

const buildSqlFileContents = (rows: SkillRow[]): string => {
  const header = [
    "-- Auto-generated by scripts/seedSkillsTable.ts",
    "-- Do not edit manually. Run `bun run scripts/seedSkillsTable.ts` after updating the skill tree definitions.",
    "",
    "BEGIN;"
  ];

  const statements = rows.map((row) => buildInsertStatement(row));
  const footer = ["COMMIT;", ""];

  return [...header, ...statements, ...footer].join("\n");
};

const main = () => {
  ensureDirectory(OUTPUT_DIRECTORY);
  const rows = buildSkillRows();
  const contents = buildSqlFileContents(rows);
  writeFileSync(OUTPUT_FILE, contents);
  console.log(`Wrote ${rows.length} skill rows to ${path.relative(process.cwd(), OUTPUT_FILE)}`);
};

main();
